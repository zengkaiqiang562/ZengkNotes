## 响应码 ##
### 304 (Not Modified) ###
304 状态码返回时，不包含任何响应的主体部分

参考 请求首部字段"If-Modified-Since"

## 请求首部字段 ##
### Accept ###
Accept 字段用于告知服务器，客户端或用户代理能够处理的媒体类型（MIME Type），及媒体类型的相对优先级。

服务器端在接收到客户端请求后，可能会返回数据给客户端。返回的数据可能是文本文件、图片文件、音视频文件
或二进制文件等等，并且每种文件又会存在多种格式：

	如文本文件格式可能有 text/html, text/plain, text/css, ...

	图片文件格式可能有  image/png, image/jpeg, image/gif, image/bmp, ...

	音频文件可能有

	视频文件可能有

	应用程序使用的二进制文件可能有

以上用于描述各种文件格式的形式 "type/subType"，称为 MIME Type（媒体类型）。

客户端（或用户代理）可能处理不了所有媒体类型的数据，此时，在发送请求给服务器时，
就需要通过Accept字段告诉服务器，客户端（或用户代理）能够处理的媒体类型。
于是，服务器在返回数据时，就会参考Accept字段指定的媒体类型，为客户端提供合适的媒体类型的数据（此处
的服务器返回的数据就是响应实体内部的数据），并且服务器还会通过实体首部字段 "Content-Type" 告知
客户端（或用户代理），所返回的响应实体中的数据的媒体类型。

Accept字段可一次性指定多个媒体类型，并通过权重 q 来设置每个媒体类型的权重。
权重 q 的范围时[0, 1]，取值时可精确到小数点后3位。如果指定的媒体类型没有设置权重 q，则默认 q=1。
当权重 q=0 时，优先级最低，当权重 q=1 时， 优先级最高。

举例：

	Accept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8

如上，指定媒体类型时，可使用通配符"*"，表示任意类型。
如 "*/*" 表示数据可以是任意文件，任意文件格式。
"text/*" 表示数据只能是文本文件，但可以是任意文本文件格式。
"image/*" 表示数据只能是图片文件，但可以是任意图片文件格式。


### Accept-Charset ###
此字段用来告知服务器，客户端或用户代理读取服务器返回的响应实体中的内容时，支持的字符集，及所有支持的
字符集的相对优先级顺序。

服务器应该参考客户端发出的请求首部字段 Accept-Charset 指定的字符集，对返回给客户端的响应实体内容进行
编码。如果服务器采用的编码集不是客户端支持的，那么客户端读取响应实体内容时，不能正确解码。

服务器在返回数据给客户端时，会通过实体首部字段 Content-Type中的附加参数charset指定所返回的响应实体
内容的编码字符集。

Accept-Charset字段可一次性指定多个字符集，并通过权重 q 来设置每个字符集的权重。从而决定相对优先级。

举例：

	Accept-Charset: iso-8859-5, unicode-1-1;q=0.8

### Accept-Encoding ###
Accept-Encoding 首部字段用来告知服务器，用户代理支持的内容编码方式，及内容编码的优先级顺序。
可一次性指定多种内容编码，即Accept-Encoding字段可对应有多个值。

举例：
		
	Accept-Encoding: gzip, deflate

常用的内容编码方式：

	gzip  由文件压缩程序 gzip(GUN zip) 生成的编码格式（RFC1852），
			此编码格式采用 Lempel-Ziv 算法（LZ77）， 和 
			32位循环冗余校验（Cyclic Redundancy Check， CRC）。

	compress  有UNIX文件压缩程序 compress 生成的编码格式， 
				此编码格式采用 Lempel-Ziv-Welch 算法（LZW）

	deflate  组合使用 zlib 编码格式（RFC1950）， 和由 deflate 压缩算法（RFC1951）
				生成的编码格式。

	identity  不执行压缩，或不会变化的默认编码格式

Accept-Encoding 字段中，使用权重 q 表示内容编码方式的相对优先级（与请求首部字段 Accept 相同）。
另外，Accept-Encoding 字段中也可使用通配符 "*" 指定任意的编码格式

**If-Modified-Since**
"If-Modified-Since" 指定一个时间点 time （年月日时分秒类型的时间）
客户端只接收服务器中在时间点time之后更新了的数据，
如果服务器中的将要响应给客户端的数据在time之后没有更新过，那么HTTP协议的响应状态码为304(Not Modified)

另外，当服务器向客户端响应数据时，会通过实体首部字段 "Last-Modified" 标记数据最近更新的时间点

## 响应首部字段 ##

### Age ###
此字段告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。

举例：

	Age: 600



## 实体首部字段 （实体可以是请求实体或响应实体） ##
### Content-Encoding ###
Content-Encoding用来告知客户端，服务器对响应实体的内容所选用的编码方式。
内容编码是指在不丢失实体信息的前提下，所进行的压缩。

举例：

	Content-Encoding: gzip

内容编码的方式有4种：

	gzip  由文件压缩程序 gzip(GUN zip) 生成的编码格式（RFC1852），
			此编码格式采用 Lempel-Ziv 算法（LZ77）， 和 
			32位循环冗余校验（Cyclic Redundancy Check， CRC）。

	compress  有UNIX文件压缩程序 compress 生成的编码格式， 
				此编码格式采用 Lempel-Ziv-Welch 算法（LZW）

	deflate  组合使用 zlib 编码格式（RFC1950）， 和由 deflate 压缩算法（RFC1951）
				生成的编码格式。

	identity  不执行压缩，或不会变化的默认编码格式

客户端根据服务器返回的实体首部字段Content-Encoding指定的内容编码方式，对服务器返回的响应实体中的内容
进行解码。

客户端或用户代理可能不会支持所有的内容编码方式，所以在客户端向服务器发送HTTP请求时，会把客户端支持的
内容编码方式通过请求首部字段"Accept-Encoding"告知服务器。
于是，服务器可以根据"Accept-Encoding"字段表示的客户端支持的内容编码方式，对响应的内容数据进行编码。
服务器具体采用哪种内容编码方式，则通过响应首部字段"Content-Encoding"告知客户端。

### Content-Type ###
Content-Type 字段指定了实体内容数据的媒体类型（MIME 类型）。
字段值格式形如 "type/subType[; 可选参数]"。

举例：

	Content-Type: text/html; charset=UTF-8

其中附加参数charset指定实体内容的编码字符集

### Content-Length ###
此字段表示实体内容数据的大小（实体内容不包含boundary分隔符）
单位：byte 字节。

实体内容大小的计算参考 文档RFC2016中的4.4章节

### Expires ###
通常作为响应的实体首部字段。用于指定实体内容数据的失效日期。

举例：

	Expires: Wed, 21 Oct 2015 07:28:00 GMT

当源服务器（数据源所在的服务器）返回内容数据给 缓存服务器（对源服务器返回的内容数据做了缓存备份的
服务器，如果直接在客户端做缓存备份，那么缓存服务器就是指客户端）时，缓存服务器会参考Expires字段对
源服务器响应的实体内容做缓存备份，这份缓存副本在Expires指定的日期之间都有效。

当客户端请求的数据，在缓存服务器中有缓存备份，且当前HTTP请求报文的日期仍在这份缓存副本的有效期之内，
那么缓存服务器则直接将这份缓存副本作为本次请求的响应实体内容返回给客户端。（当客户端作为缓存服务器时，
相当于从本地获取请求数据，并没有访问网络）。

当客户端请求的数据，在缓存服务器中有缓存备份，但是当前HTTP请求报文的日期超出了这份缓存副本的有效期时，
缓存服务器则会转向源服务器请求客户端需要的资源。

如果源服务器不希望缓存服务器对资源做缓存备份时，可以为Expires字段指定与Data字段相同的日期。即
缓存副本的有效期不会超过本次服务器发出HTTP响应报文的日期，所以即使做了缓存，也是过期的缓存，因此不会
再做缓存处理。

特别的，当源服务器返回的HTTP响应报文中包含 Cache-Control 首部字段，且 Cache-Control 字段中
设置了 "max-age" 或者 "s-max-age" 指令时，那么本次HTTP响应报文中的 Expires 首部字段会被忽略。

### Last-Modified ###
此字段指定实体内容数据最后一次被修改的日期

当服务器返回给客户端的HTTP响应报文中包含响应实体内容时，此次HTTP响应报文中会通过 Last-Modified 首部
字段表明本次响应的实体内容数据，在服务器中最后一次被修改的日期。

举例：

	Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT

此字段通常被用作一个验证器来判断接收到的或者存储的资源是否彼此一致。
由于精确度比 ETag 要低，所以这是一个备用机制。

包含有 If-Modified-Since 或 If-Unmodified-Since 首部字段的条件请求会使用这个字段。

## HTTP/1.1 通用首部字段 ##

### Date ###
Date字段表示创建 HTTP 报文的日期和时间

格式：

	Date: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT

其中：

	<day-name>
    "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", 或 "Sun" 之一 （区分大小写）。

	<day>
    2位数字表示天数，例如， "04" 或 "23"。

	<month>
    "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" 
	之一（区分大小写）。

	<year>
    4位数字表示年份，例如， "1990" 或 "2016"。

	<hour>
    2位数字表示小时数，例如， "09" 或 "23"。

	<minute>
    2位数字表示分钟数，例如， "04" 或 "59"。

	<second>
    2位数字表示秒数，例如， "04" 或 "59"。

	GMT
    格林尼治标准时间。在HTTP协议中，时间都是用格林尼治标准时间来表示的，而不是本地时间。

举例：

	Date: Wed, 21 Oct 2015 07:28:00 GMT

### Cache-Control ###
通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。

指令的参数是可选的，多个指令之间通过逗号","分隔


